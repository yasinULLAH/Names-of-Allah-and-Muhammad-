
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beautiful Names Challenge</title>
    <style>
        :root {
            --primary: #3a7bd5;
            --secondary: #00d2ff;
            --accent: #f9c270;
            --dark: #1a1a2e;
            --light: #f8f9fa;
            --success: #28a745;
            --error: #dc3545;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            --gradient: linear-gradient(135deg, var(--primary), var(--secondary));
            --radius: 12px;
            --transition: all 0.3s ease;
        }

        [data-theme="gold"] {
            --primary: #d4af37;
            --secondary: #b8860b;
            --accent: #fff7e6;
            --dark: #402e32;
            --light: #fffaf0;
        }
        
        [data-theme="emerald"] {
            --primary: #2ecc71;
            --secondary: #27ae60;
            --accent: #e8f8f5;
            --dark: #1e3d35;
            --light: #f0fff4;
        }
        
        [data-theme="royal"] {
            --primary: #8e44ad;
            --secondary: #9b59b6;
            --accent: #f5eef8;
            --dark: #2c1338;
            --light: #f8f0fc;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--light);
            color: var(--dark);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            transition: var(--transition);
            overflow-x: hidden;
        }

        header {
            background: var(--gradient);
            color: white;
            padding: 1rem;
            text-align: center;
            box-shadow: var(--shadow);
            position: relative;
            overflow: hidden;
            z-index: 1;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSJyZ2JhKDI1NSwyNTUsMjU1LDAuMSkiIHN0cm9rZS13aWR0aD0iMiIgZD0iTTUwLDUgTDk1LDUwIEw1MCw5NSBMNSw1MCBaIi8+PC9zdmc+');
            opacity: 0.1;
            z-index: -1;
        }

        h1 {
            font-size: 2.2rem;
            margin-bottom: 0.5rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .subtitle {
            font-size: 1.2rem;
            font-weight: 300;
            opacity: 0.9;
        }

        .container {
            flex: 1;
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
            padding: 2rem 1rem;
            position: relative;
        }

        .card {
            background: white;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            overflow: hidden;
            position: relative;
        }

        .card-title {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: var(--primary);
        }

        .btn {
            background: var(--gradient);
            color: white;
            border: none;
            border-radius: var(--radius);
            padding: 0.7rem 1.2rem;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            box-shadow: var(--shadow);
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            outline: none;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn-secondary {
            background: var(--light);
            color: var(--primary);
            border: 1px solid var(--primary);
            box-shadow: none;
        }

        .btn-round {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            padding: 0;
        }

        .flex {
            display: flex;
        }

        .flex-col {
            flex-direction: column;
        }

        .flex-wrap {
            flex-wrap: wrap;
        }

        .justify-between {
            justify-content: space-between;
        }

        .justify-center {
            justify-content: center;
        }

        .items-center {
            align-items: center;
        }

        .gap-1 {
            gap: 0.5rem;
        }

        .gap-2 {
            gap: 1rem;
        }

        .gap-3 {
            gap: 1.5rem;
        }

        .mb-1 {
            margin-bottom: 0.5rem;
        }

        .mb-2 {
            margin-bottom: 1rem;
        }

        .mb-3 {
            margin-bottom: 1.5rem;
        }

        .mt-2 {
            margin-top: 1rem;
        }

        .w-full {
            width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .glow {
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px var(--primary), 0 0 20px var(--primary);
            }
            to {
                text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px var(--primary), 0 0 40px var(--primary);
            }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }

        .tab {
            padding: 0.7rem 1.2rem;
            border-radius: var(--radius);
            cursor: pointer;
            transition: var(--transition);
            background: rgba(255, 255, 255, 0.8);
            flex: 1 1 auto;
            text-align: center;
            font-weight: 500;
        }

        .tab.active {
            background: var(--gradient);
            color: white;
            box-shadow: var(--shadow);
        }

        .tab:hover:not(.active) {
            background: rgba(255, 255, 255, 1);
            box-shadow: var(--shadow);
        }

        .screens > div {
            display: none;
        }

        .screens > div.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        .name-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1rem;
        }

        .name-card {
            background: white;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow: hidden;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            flex-direction: column;
            position: relative;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .name-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        }

        .name-card-header {
            background: var(--gradient);
            color: white;
            padding: 1rem;
            text-align: center;
        }

        .name-card-body {
            padding: 1rem;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .arabic {
            font-size: 1.8rem;
            margin-bottom: 0.5rem;
            line-height: 1.5;
            direction: rtl;
            font-family: 'Traditional Arabic', 'Scheherazade New', serif;
        }

        .meaning {
            font-size: 1rem;
            margin-bottom: 0.5rem;
            color: var(--dark);
        }

        .name-card-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            border-top: 1px solid rgba(0, 0, 0, 0.05);
            background: rgba(0, 0, 0, 0.02);
        }

        .memory-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin: 1rem 0;
        }

        .memory-card {
            aspect-ratio: 2/3;
            perspective: 1000px;
            cursor: pointer;
        }

        .memory-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .memory-card.flipped .memory-card-inner {
            transform: rotateY(180deg);
        }

        .memory-card-front, .memory-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: var(--radius);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            text-align: center;
        }

        .memory-card-front {
            background: var(--gradient);
            color: white;
            box-shadow: var(--shadow);
        }

        .memory-card-back {
            background: white;
            color: var(--dark);
            transform: rotateY(180deg);
            box-shadow: var(--shadow);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .quiz-card {
            padding: 2rem;
            margin-bottom: 1rem;
        }

        .quiz-options {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
        }

        .quiz-option {
            background: white;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--radius);
            padding: 1rem;
            cursor: pointer;
            transition: var(--transition);
        }

        .quiz-option:hover {
            background: var(--light);
            transform: translateY(-2px);
        }

        .quiz-option.selected {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .quiz-option.correct {
            background: var(--success);
            color: white;
            border-color: var(--success);
        }

        .quiz-option.incorrect {
            background: var(--error);
            color: white;
            border-color: var(--error);
        }

        .progress-container {
            height: 8px;
            background: var(--light);
            border-radius: 4px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-bar {
            height: 100%;
            background: var(--gradient);
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
        }

        .setting-card {
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: var(--radius);
            padding: 1.5rem;
            background: white;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--primary);
        }

        input:checked + .slider:before {
            transform: translateX(30px);
        }

        .range {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 5px;  
            background: #d7dcdf;
            outline: none;
        }

        .range::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%; 
            background: var(--primary);
            cursor: pointer;
        }

        .range::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
        }

        .theme-switcher {
            display: flex;
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .theme-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .theme-option:hover {
            transform: scale(1.1);
        }

        .theme-option.active {
            box-shadow: 0 0 0 2px white, 0 0 0 4px var(--primary);
        }

        .theme-default {
            background: linear-gradient(135deg, #3a7bd5, #00d2ff);
        }

        .theme-gold {
            background: linear-gradient(135deg, #d4af37, #b8860b);
        }

        .theme-emerald {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
        }

        .theme-royal {
            background: linear-gradient(135deg, #8e44ad, #9b59b6);
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.5);
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: var(--radius);
            max-width: 600px;
            width: 90%;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            position: relative;
            animation: zoomIn 0.3s;
        }

        @keyframes zoomIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .close-modal {
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 1.5rem;
            cursor: pointer;
        }

        .badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 999px;
            font-size: 0.75rem;
            font-weight: bold;
            background: var(--light);
            color: var(--primary);
        }

        .badge-success {
            background: var(--success);
            color: white;
        }

        .badge-primary {
            background: var(--primary);
            color: white;
        }

        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 1rem;
            background: white;
            color: var(--dark);
            border-radius: var(--radius);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            max-width: 300px;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
        }

        .notification.show {
            transform: translateY(0);
            opacity: 1;
        }

        .loader {
            display: inline-block;
            width: 30px;
            height: 30px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .stars {
            display: flex;
            gap: 0.25rem;
        }

        .star {
            color: #ddd;
            font-size: 1.2rem;
        }

        .star.filled {
            color: gold;
        }

        @media (max-width: 768px) {
            .tabs {
                flex-direction: column;
            }
            
            .memory-board {
                grid-template-columns: repeat(2, 1fr);
            }

            .settings-grid {
                grid-template-columns: 1fr;
            }

            .quiz-options {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body data-theme="default">
<header>
<h1>Beautiful Names Challenge</h1>
<p class="subtitle">Learn the 99 Names of Allah \& Prophet Muhammad's Names</p>
</header>

    <div class="container">
        <nav class="tabs">
            <div class="tab active" data-tab="learn">Learn</div>
            <div class="tab" data-tab="play">Play</div>
            <div class="tab" data-tab="progress">Progress</div>
            <div class="tab" data-tab="settings">Settings</div>
        </nav>
    
        <div class="screens">
            <div class="screen active" data-screen="learn">
                <div class="card mb-3">
                    <div class="flex justify-between items-center mb-2">
                        <h2 class="card-title">Beautiful Names</h2>
                        <div class="flex gap-1">
                            <button class="btn btn-secondary btn-round" id="nameFilter">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                    <path d="M6 10.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 0 1h-3a.5.5 0 0 1-.5-.5zm-2-3a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm-2-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5z"/>
                                </svg>
                            </button>
                            <button class="btn btn-secondary btn-round" id="toggleFavorites">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                    <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="flex justify-between mb-3">
                        <select id="nameCategory" class="btn btn-secondary">
                            <option value="all">All Names</option>
                            <option value="allah">Names of Allah</option>
                            <option value="prophet">Names of Prophet</option>
                        </select>
                        <div class="flex gap-1">
                            <input type="text" id="searchNames" placeholder="Search names..." class="btn btn-secondary">
                        </div>
                    </div>
                    <div class="name-grid" id="nameGrid"></div>
                </div>
            </div>
    
            <div class="screen" data-screen="play">
                <div class="card mb-3">
                    <h2 class="card-title">Choose Game Mode</h2>
                    <div class="flex flex-wrap gap-2">
                        <button class="btn" id="startMatch">Matching Game</button>
                        <button class="btn" id="startMemory">Memory Game</button>
                        <button class="btn" id="startQuiz">Quiz Challenge</button>
                    </div>
                </div>
                <div id="gameArea" class="card" style="display: none;">
                    <div class="flex justify-between items-center mb-2">
                        <h2 class="card-title" id="gameTitle">Game Title</h2>
                        <div class="flex gap-1">
                            <button class="btn btn-secondary" id="endGame">End Game</button>
                        </div>
                    </div>
                    <div class="progress-container">
                        <div class="progress-bar" id="gameProgress" style="width: 0%;"></div>
                    </div>
                    <div id="gameContent"></div>
                </div>
            </div>
    
            <div class="screen" data-screen="progress">
                <div class="card mb-3">
                    <h2 class="card-title">Your Learning Progress</h2>
                    <div class="flex flex-col gap-2 mb-3">
                        <div class="flex justify-between items-center">
                            <div>Names Mastered</div>
                            <div class="badge badge-success"><span id="namesMastered">0</span>/99</div>
                        </div>
                        <div class="progress-container">
                            <div class="progress-bar" id="masteryProgress" style="width: 0%;"></div>
                        </div>
                    </div>
                    <div class="flex flex-col gap-2">
                        <h3 class="mb-1">Learning Stats</h3>
                        <div class="flex justify-between items-center">
                            <div>Games Played</div>
                            <div id="gamesPlayed">0</div>
                        </div>
                        <div class="flex justify-between items-center">
                            <div>Time Spent Learning</div>
                            <div id="timeSpent">0 min</div>
                        </div>
                        <div class="flex justify-between items-center">
                            <div>Current Streak</div>
                            <div id="currentStreak">0 days</div>
                        </div>
                    </div>
                </div>
                <div class="card">
                    <h2 class="card-title">Review Schedule</h2>
                    <div id="reviewSchedule" class="flex flex-col gap-2">
                        <div class="text-center py-4">
                            No names scheduled for review yet
                        </div>
                    </div>
                </div>
            </div>
    
            <div class="screen" data-screen="settings">
                <div class="card mb-3">
                    <h2 class="card-title">App Settings</h2>
                    <div class="settings-grid">
                        <div class="setting-card">
                            <h3 class="mb-2">Theme</h3>
                            <div class="theme-switcher">
                                <div class="theme-option theme-default active" data-theme="default"></div>
                                <div class="theme-option theme-gold" data-theme="gold"></div>
                                <div class="theme-option theme-emerald" data-theme="emerald"></div>
                                <div class="theme-option theme-royal" data-theme="royal"></div>
                            </div>
                        </div>
                        <div class="setting-card">
                            <h3 class="mb-2">Language Preference</h3>
                            <select id="langPreference" class="btn btn-secondary w-full">
                                <option value="english">English</option>
                                <option value="urdu">Urdu</option>
                                <option value="pashto">Pashto</option>
                            </select>
                        </div>
                        <div class="setting-card">
                            <h3 class="mb-2">Audio</h3>
                            <div class="flex justify-between items-center mb-2">
                                <span>Enable Audio</span>
                                <label class="switch">
                                    <input type="checkbox" id="audioEnabled" checked>
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="mb-2">
                                <div class="flex justify-between mb-1">
                                    <span>Volume</span>
                                    <span id="volumeValue">80%</span>
                                </div>
                                <input type="range" min="0" max="100" value="80" class="range" id="volumeRange">
                            </div>
                        </div>
                        <div class="setting-card">
                            <h3 class="mb-2">Learning</h3>
                            <div class="flex justify-between items-center mb-2">
                                <span>Daily Reminders</span>
                                <label class="switch">
                                    <input type="checkbox" id="dailyReminders">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="mb-2">
                                <div class="flex justify-between mb-1">
                                    <span>Daily Learning Goal</span>
                                    <span id="learningGoalValue">5 names</span>
                                </div>
                                <input type="range" min="1" max="20" value="5" class="range" id="learningGoalRange">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="card">
                    <h2 class="card-title">Data Management</h2>
                    <p class="mb-2">Manage your learning data and preferences</p>
                    <div class="flex gap-2">
                        <button class="btn" id="exportData">Export Data</button>
                        <button class="btn" id="importData">Import Data</button>
                        <button class="btn btn-secondary" id="resetData">Reset All Data</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="modal" id="nameDetailModal">
        <div class="modal-content">
            <span class="close-modal" id="closeNameDetail">&times;</span>
            <h2 class="card-title" id="modalNameTitle">Name Detail</h2>
            <div class="arabic text-center mb-3 glow" id="modalNameArabic"></div>
            <div class="flex flex-col gap-2 mb-3">
                <div class="flex justify-between">
                    <strong>English:</strong>
                    <span id="modalNameEnglish"></span>
                </div>
                <div class="flex justify-between">
                    <strong>Urdu:</strong>
                    <span id="modalNameUrdu"></span>
                </div>
                <div class="flex justify-between">
                    <strong>Pashto:</strong>
                    <span id="modalNamePashto"></span>
                </div>
            </div>
            <div class="mb-3">
                <h3 class="mb-1">Significance</h3>
                <p id="modalNameDescription"></p>
            </div>
            <div class="flex justify-between mb-2">
                <div class="flex gap-2">
                    <button class="btn btn-secondary btn-round" id="playNameAudio">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                            <path d="m11.596 8.697-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/>
                        </svg>
                    </button>
                    <button class="btn btn-secondary btn-round" id="toggleFavoriteModal">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" id="favoriteIcon">
                            <path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>
                        </svg>
                    </button>
                </div>
                <div class="stars">
                    <span class="star" data-value="1">★</span>
                    <span class="star" data-value="2">★</span>
                    <span class="star" data-value="3">★</span>
                    <span class="star" data-value="4">★</span>
                    <span class="star" data-value="5">★</span>
                </div>
            </div>
            <div class="flex justify-between">
                <div>
                    <span class="badge" id="modalMastery">Learning</span>
                </div>
                <div>Next review: <span id="modalNextReview">Today</span></div>
            </div>
        </div>
    </div>
    
    <div class="notification" id="notification">
        <div id="notificationMessage"></div>
    </div>
    
    <script>
        // Database setup
        let db;
        const DB_NAME = 'BeautifulNamesDB';
        const DB_VERSION = 1;
        const NAMES_STORE = 'names';
        const PROGRESS_STORE = 'progress';
        const SETTINGS_STORE = 'settings';
    
        const req = indexedDB.open(DB_NAME, DB_VERSION);
    
        req.onupgradeneeded = (event) => {
            db = event.target.result;
            
            // Names store
            if (!db.objectStoreNames.contains(NAMES_STORE)) {
                const namesStore = db.createObjectStore(NAMES_STORE, { keyPath: 'id' });
                namesStore.createIndex('category', 'category', { unique: false });
                namesStore.createIndex('favorite', 'favorite', { unique: false });
            }
            
            // Progress store
            if (!db.objectStoreNames.contains(PROGRESS_STORE)) {
                const progressStore = db.createObjectStore(PROGRESS_STORE, { keyPath: 'id' });
                progressStore.createIndex('userId', 'userId', { unique: false });
            }
            
            // Settings store
            if (!db.objectStoreNames.contains(SETTINGS_STORE)) {
                db.createObjectStore(SETTINGS_STORE, { keyPath: 'id' });
            }
        };
    
        req.onsuccess = (event) => {
            db = event.target.result;
            initApp();
        };
    
        req.onerror = (event) => {
            showNotification('Failed to open database: ' + event.target.errorCode, 'error');
        };
    
        // Data models
        const NAMES_DATA = [
            // Allah's Names (First 20 for brevity)
            {id: "allah_1", name: "الرحمن", transliteration: "Ar-Rahman", english: "The Most Compassionate", urdu: "بے حد رحم کرنے والا", pashto: "ډیر مهربان", category: "allah", description: "The Most Compassionate whose mercy encompasses all creation.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "allah_2", name: "الرحيم", transliteration: "Ar-Raheem", english: "The Most Merciful", urdu: "نہایت رحم والا", pashto: "ډير مهربان", category: "allah", description: "The Most Merciful whose mercy is manifested in the forgiveness of sins.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "allah_3", name: "الملك", transliteration: "Al-Malik", english: "The King", urdu: "بادشاہ، حکمران", pashto: "بادشاه", category: "allah", description: "The King and Owner of Dominion who has authority over all creation.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "allah_4", name: "القدوس", transliteration: "Al-Quddus", english: "The Most Holy", urdu: "پاک ذات", pashto: "پاک ذات", category: "allah", description: "The Most Holy, free from all imperfections and defects.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "allah_5", name: "السلام", transliteration: "As-Salam", english: "The Source of Peace", urdu: "سلامتی دینے والا", pashto: "سلامتي وركوونكى", category: "allah", description: "The Source of Peace who is free from all defects and deficiencies.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "allah_6", name: "المؤمن", transliteration: "Al-Mu'min", english: "The Giver of Faith", urdu: "امن دینے والا", pashto: "امن وركوونكى", category: "allah", description: "The Giver of Faith who provides security and removes fear.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "allah_7", name: "المهيمن", transliteration: "Al-Muhaymin", english: "The Guardian", urdu: "نگہبان", pashto: "څارونكى", category: "allah", description: "The Guardian who watches over and protects all of creation.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "allah_8", name: "العزيز", transliteration: "Al-Aziz", english: "The Almighty", urdu: "غالب", pashto: "غالب، برلاسى", category: "allah", description: "The Almighty who overcomes and cannot be overcome.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "allah_9", name: "الجبار", transliteration: "Al-Jabbar", english: "The Compeller", urdu: "زبردست", pashto: "زورور", category: "allah", description: "The Compeller who repairs all broken things and enforces His will.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "allah_10", name: "المتكبر", transliteration: "Al-Mutakabbir", english: "The Greatest", urdu: "متکبر", pashto: "لوى", category: "allah", description: "The Greatest who demonstrates His greatness in all things and ways.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "allah_11", name: "الخالق", transliteration: "Al-Khaliq", english: "The Creator", urdu: "پیدا کرنے والا", pashto: "پيدا كوونكى", category: "allah", description: "The Creator who brings things into existence from nothingness.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "allah_12", name: "البارئ", transliteration: "Al-Bari", english: "The Evolver", urdu: "بنانے والا", pashto: "جوړوونكى", category: "allah", description: "The Evolver who creates with perfect proportion and harmony.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "allah_13", name: "المصور", transliteration: "Al-Musawwir", english: "The Fashioner", urdu: "صورت بنانے والا", pashto: "شكل وركوونكى", category: "allah", description: "The Fashioner who shapes and designs all things with perfect wisdom.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "allah_14", name: "الغفار", transliteration: "Al-Ghaffar", english: "The Forgiver", urdu: "بخشنے والا", pashto: "بخښونكى", category: "allah", description: "The Forgiver who forgives sins repeatedly.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "allah_15", name: "القهار", transliteration: "Al-Qahhar", english: "The Subduer", urdu: "زبردست قابو پانے والا", pashto: "قابو كوونكى", category: "allah", description: "The Subduer who has absolute power over His creation.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "allah_16", name: "الوهاب", transliteration: "Al-Wahhab", english: "The Bestower", urdu: "دینے والا", pashto: "وركوونكى", category: "allah", description: "The Bestower who gives freely without expectation of return.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "allah_17", name: "الرزاق", transliteration: "Ar-Razzaq", english: "The Provider", urdu: "رزق دینے والا", pashto: "روزي وركوونكى", category: "allah", description: "The Provider who creates all means of nourishment and sustenance.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "allah_18", name: "الفتاح", transliteration: "Al-Fattah", english: "The Opener", urdu: "فیصلہ کرنے والا", pashto: "پرانيستونكى", category: "allah", description: "The Opener who opens the doors of mercy and sustenance.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "allah_19", name: "العليم", transliteration: "Al-Alim", english: "The All-Knowing", urdu: "جاننے والا", pashto: "پوهه", category: "allah", description: "The All-Knowing whose knowledge encompasses all things.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "allah_20", name: "القابض", transliteration: "Al-Qabid", english: "The Constrictor", urdu: "قبض کرنے والا", pashto: "نيوونكى", category: "allah", description: "The Constrictor who constricts provision by His wisdom.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            
            // Prophet Muhammad's Names (First 10 for brevity)
            {id: "prophet_1", name: "محمد", transliteration: "Muhammad", english: "The Praised One", urdu: "تعریف کیا گیا", pashto: "ستايل شوى", category: "prophet", description: "The most praised one, whose attributes and actions are praiseworthy.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "prophet_2", name: "أحمد", transliteration: "Ahmad", english: "The Most Praised", urdu: "زیادہ تعریف کیا گیا", pashto: "ډېر ستايل شوى", category: "prophet", description: "The one who praises Allah more than others and is most deserving of praise.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "prophet_3", name: "الماحي", transliteration: "Al-Mahi", english: "The Eraser", urdu: "مٹانے والا", pashto: "له منځه وړونكى", category: "prophet", description: "The one through whom Allah erases disbelief.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "prophet_4", name: "الحاشر", transliteration: "Al-Hashir", english: "The Gatherer", urdu: "اکٹھا کرنے والا", pashto: "راټولوونكى", category: "prophet", description: "The one at whose feet people will be gathered on the Day of Judgment.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "prophet_5", name: "العاقب", transliteration: "Al-Aqib", english: "The Successor", urdu: "آخری نبی", pashto: "وروستى", category: "prophet", description: "The last prophet after whom there is no other prophet.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "prophet_6", name: "المقفي", transliteration: "Al-Muqaffi", english: "The Final One", urdu: "پیچھے آنے والا", pashto: "پسې راتلونكى", category: "prophet", description: "The one who followed all previous prophets and messengers.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "prophet_7", name: "نبي الرحمة", transliteration: "Nabi-ur-Rahmah", english: "Prophet of Mercy", urdu: "رحمت والا نبی", pashto: "د رحمت نبي", category: "prophet", description: "The prophet who was sent as a mercy to all creation.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "prophet_8", name: "نبي التوبة", transliteration: "Nabi-ut-Tawbah", english: "Prophet of Repentance", urdu: "توبہ کا نبی", pashto: "د توبې نبي", category: "prophet", description: "The prophet through whom Allah accepts repentance.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "prophet_9", name: "طه", transliteration: "Taha", english: "Taha", urdu: "طہ", pashto: "طه", category: "prophet", description: "A name of honor mentioned in Surah Taha of the Quran.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null},
            {id: "prophet_10", name: "يس", transliteration: "Yaseen", english: "Yaseen", urdu: "یس", pashto: "يس", category: "prophet", description: "A name of honor mentioned in Surah Yaseen of the Quran.", favorite: false, mastery: 0, nextReview: new Date(), lastReviewed: null, audio: null}
        ];
    
        // User settings
        const DEFAULT_SETTINGS = {
            id: 'userSettings',
            theme: 'default',
            language: 'english',
            audio: {
                enabled: true,
                volume: 0.8
            },
            learning: {
                dailyReminders: false,
                dailyGoal: 5,
                lastActive: new Date()
            },
            userId: 'default_user'
        };
    
        // Game stats
        const DEFAULT_PROGRESS = {
            id: 'userProgress',
            userId: 'default_user',
            gamesPlayed: 0,
            timeSpent: 0,
            streak: {
                current: 0,
                longest: 0,
                lastDate: null
            }
        };
    
        // Utility functions
        const utils = {
            getStore: (storeName, mode = 'readonly') => {
                const tx = db.transaction(storeName, mode);
                return tx.objectStore(storeName);
            },
            
            saveToDb: (storeName, data) => {
                return new Promise((resolve, reject) => {
                    const store = utils.getStore(storeName, 'readwrite');
                    const req = store.put(data);
                    
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
            },
            
            getFromDb: (storeName, key) => {
                return new Promise((resolve, reject) => {
                    const store = utils.getStore(storeName);
                    const req = store.get(key);
                    
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
            },
            
            getAllFromDb: (storeName) => {
                return new Promise((resolve, reject) => {
                    const store = utils.getStore(storeName);
                    const req = store.getAll();
                    
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
            },
            
            deleteFromDb: (storeName, key) => {
                return new Promise((resolve, reject) => {
                    const store = utils.getStore(storeName, 'readwrite');
                    const req = store.delete(key);
                    
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
            },
            
            clearStore: (storeName) => {
                return new Promise((resolve, reject) => {
                    const store = utils.getStore(storeName, 'readwrite');
                    const req = store.clear();
                    
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
            },
            
            formatDate: (date) => {
                if (!date) return 'N/A';
                const d = new Date(date);
                return d.toLocaleDateString();
            },
            
            formatNextReview: (date) => {
                if (!date) return 'Not scheduled';
                
                const now = new Date();
                const reviewDate = new Date(date);
                const diffTime = reviewDate - now;
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                
                if (diffDays < 0) return 'Overdue';
                if (diffDays === 0) return 'Today';
                if (diffDays === 1) return 'Tomorrow';
                if (diffDays < 7) return `In ${diffDays} days`;
                if (diffDays < 30) return `In ${Math.floor(diffDays / 7)} week(s)`;
                return `In ${Math.floor(diffDays / 30)} month(s)`;
            },
            
            shuffle: (array) => {
                let currentIndex = array.length;
                let randomIndex;
                
                while (currentIndex !== 0) {
                    randomIndex = Math.floor(Math.random() * currentIndex);
                    currentIndex--;
                    
                    [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
                }
                
                return array;
            },
            
            getMasteryLabel: (level) => {
                if (level >= 5) return 'Mastered';
                if (level >= 3) return 'Familiar';
                if (level >= 1) return 'Learning';
                return 'New';
            },
            
            getMasteryClass: (level) => {
                if (level >= 5) return 'badge-success';
                if (level >= 3) return 'badge-primary';
                return '';
            },
            
            updateSrsInterval: (name, correct) => {
                let mastery = name.mastery || 0;
                const now = new Date();
                
                if (correct) {
                    mastery += 1;
                    if (mastery > 5) mastery = 5;
                } else {
                    mastery -= 1;
                    if (mastery < 0) mastery = 0;
                }
                
                let nextInterval;
                switch (mastery) {
                    case 0: nextInterval = 1; break; // 1 day
                    case 1: nextInterval = 2; break; // 2 days
                    case 2: nextInterval = 4; break; // 4 days
                    case 3: nextInterval = 7; break; // 1 week
                    case 4: nextInterval = 14; break; // 2 weeks
                    case 5: nextInterval = 30; break; // 1 month
                    default: nextInterval = 1;
                }
                
                const nextReview = new Date();
                nextReview.setDate(now.getDate() + nextInterval);
                
                return {
                    ...name,
                    mastery,
                    lastReviewed: now,
                    nextReview
                };
            },
            
            speak: (text, lang = 'ar') => {
                if (!('speechSynthesis' in window)) return;
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = lang;
                utterance.volume = app.settings.audio.volume;
                
                if (app.settings.audio.enabled) {
                    speechSynthesis.speak(utterance);
                }
            }
        };
    
        // Application controller
        const app = {
            settings: { ...DEFAULT_SETTINGS },
            progress: { ...DEFAULT_PROGRESS },
            names: [],
            currentName: null,
            gameState: {
                mode: null,
                score: 0,
                total: 0,
                items: [],
                started: false,
                completed: false
            },
            
            init: async function() {
                try {
                    await this.loadSettings();
                    await this.loadProgress();
                    await this.loadNames();
                    this.bindEvents();
                    this.updateTheme();
                    this.renderNames();
                    this.updateProgress();
                    
                    // Check for daily streak
                    this.checkDailyStreak();
                } catch (error) {
                    showNotification('Error initializing app: ' + error.message, 'error');
                }
            },
            
            loadSettings: async function() {
                try {
                    const settings = await utils.getFromDb(SETTINGS_STORE, 'userSettings');
                    if (settings) {
                        this.settings = settings;
                    } else {
                        await utils.saveToDb(SETTINGS_STORE, DEFAULT_SETTINGS);
                    }
                    
                    // Update UI based on settings
                    document.getElementById('audioEnabled').checked = this.settings.audio.enabled;
                    document.getElementById('volumeRange').value = this.settings.audio.volume * 100;
                    document.getElementById('volumeValue').textContent = `${Math.round(this.settings.audio.volume * 100)}%`;
                    document.getElementById('dailyReminders').checked = this.settings.learning.dailyReminders;
                    document.getElementById('learningGoalRange').value = this.settings.learning.dailyGoal;
                    document.getElementById('learningGoalValue').textContent = `${this.settings.learning.dailyGoal} names`;
                    document.getElementById('langPreference').value = this.settings.language;
                } catch (error) {
                    console.error('Error loading settings:', error);
                    showNotification('Error loading settings', 'error');
                }
            },
            
            loadProgress: async function() {
                try {
                    const progress = await utils.getFromDb(PROGRESS_STORE, 'userProgress');
                    if (progress) {
                        this.progress = progress;
                    } else {
                        await utils.saveToDb(PROGRESS_STORE, DEFAULT_PROGRESS);
                    }
                } catch (error) {
                    console.error('Error loading progress:', error);
                    showNotification('Error loading progress', 'error');
                }
            },
            
            loadNames: async function() {
                try {
                    const names = await utils.getAllFromDb(NAMES_STORE);
                    if (names && names.length > 0) {
                        this.names = names;
                    } else {
                        // Initialize with default names
                        for (const name of NAMES_DATA) {
                            await utils.saveToDb(NAMES_STORE, name);
                        }
                        this.names = NAMES_DATA;
                    }
                } catch (error) {
                    console.error('Error loading names:', error);
                    showNotification('Error loading names', 'error');
                }
            },
            
            bindEvents: function() {
                // Tab navigation
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        
                        const targetScreen = tab.dataset.tab;
                        document.querySelectorAll('.screen').forEach(screen => {
                            screen.classList.remove('active');
                            if (screen.dataset.screen === targetScreen) {
                                screen.classList.add('active');
                            }
                        });
                    });
                });
                
                // Name filtering
                document.getElementById('nameCategory').addEventListener('change', () => this.renderNames());
                document.getElementById('searchNames').addEventListener('input', () => this.renderNames());
                document.getElementById('toggleFavorites').addEventListener('click', () => {
                    const btn = document.getElementById('toggleFavorites');
                    btn.classList.toggle('active');
                    this.renderNames();
                });
                
                // Game start buttons
                document.getElementById('startMatch').addEventListener('click', () => this.startGame('match'));
                document.getElementById('startMemory').addEventListener('click', () => this.startGame('memory'));
                document.getElementById('startQuiz').addEventListener('click', () => this.startGame('quiz'));
                document.getElementById('endGame').addEventListener('click', () => this.endGame());
                
                // Name detail modal
                document.getElementById('closeNameDetail').addEventListener('click', () => {
                    document.getElementById('nameDetailModal').classList.remove('active');
                });
                
                document.getElementById('playNameAudio').addEventListener('click', () => {
                    if (this.currentName) {
                        utils.speak(this.currentName.name);
                    }
                });
                
                document.getElementById('toggleFavoriteModal').addEventListener('click', () => {
                    if (this.currentName) {
                        this.toggleFavorite(this.currentName.id);
                    }
                });
                
                // Stars in modal
                document.querySelectorAll('.star').forEach(star => {
                    star.addEventListener('click', () => {
                        if (this.currentName) {
                            const value = parseInt(star.dataset.value);
                            this.updateMastery(this.currentName.id, value);
                        }
                    });
                });
                
                // Settings
                document.getElementById('audioEnabled').addEventListener('change', (e) => {
                    this.settings.audio.enabled = e.target.checked;
                    this.saveSettings();
                });
                
                document.getElementById('volumeRange').addEventListener('input', (e) => {
                    const volume = parseInt(e.target.value) / 100;
                    this.settings.audio.volume = volume;
                    document.getElementById('volumeValue').textContent = `${e.target.value}%`;
                    this.saveSettings();
                });
                
                document.getElementById('dailyReminders').addEventListener('change', (e) => {
                    this.settings.learning.dailyReminders = e.target.checked;
                    this.saveSettings();
                    
                    if (e.target.checked) {
this.requestNotificationPermission();
}
});

                    document.getElementById('learningGoalRange').addEventListener('input', (e) => {
                        const goal = parseInt(e.target.value);
                        this.settings.learning.dailyGoal = goal;
                        document.getElementById('learningGoalValue').textContent = `${goal} names`;
                        this.saveSettings();
                    });
                    
                    document.getElementById('langPreference').addEventListener('change', (e) => {
                        this.settings.language = e.target.value;
                        this.saveSettings();
                        this.renderNames();
                    });
                    
                    // Theme switcher
                    document.querySelectorAll('.theme-option').forEach(option => {
                        option.addEventListener('click', () => {
                            const theme = option.dataset.theme;
                            document.querySelectorAll('.theme-option').forEach(opt => opt.classList.remove('active'));
                            option.classList.add('active');
                            
                            this.settings.theme = theme;
                            this.saveSettings();
                            this.updateTheme();
                        });
                    });
                    
                    // Data management
                    document.getElementById('exportData').addEventListener('click', () => this.exportData());
                    document.getElementById('importData').addEventListener('click', () => this.importData());
                    document.getElementById('resetData').addEventListener('click', () => this.resetData());
                },
                
                updateTheme: function() {
                    document.body.dataset.theme = this.settings.theme;
                    
                    document.querySelectorAll('.theme-option').forEach(opt => {
                        opt.classList.toggle('active', opt.dataset.theme === this.settings.theme);
                    });
                },
                
                saveSettings: async function() {
                    try {
                        await utils.saveToDb(SETTINGS_STORE, this.settings);
                    } catch (error) {
                        console.error('Error saving settings:', error);
                        showNotification('Error saving settings', 'error');
                    }
                },
                
                renderNames: function() {
                    const nameGrid = document.getElementById('nameGrid');
                    nameGrid.innerHTML = '';
                    
                    const category = document.getElementById('nameCategory').value;
                    const searchTerm = document.getElementById('searchNames').value.toLowerCase();
                    const showFavorites = document.getElementById('toggleFavorites').classList.contains('active');
                    
                    let filteredNames = [...this.names];
                    
                    if (category !== 'all') {
                        filteredNames = filteredNames.filter(name => name.category === category);
                    }
                    
                    if (showFavorites) {
                        filteredNames = filteredNames.filter(name => name.favorite);
                    }
                    
                    if (searchTerm) {
                        filteredNames = filteredNames.filter(name => 
                            name.transliteration.toLowerCase().includes(searchTerm) ||
                            name.english.toLowerCase().includes(searchTerm) ||
                            name.urdu.includes(searchTerm) ||
                            name.pashto.includes(searchTerm)
                        );
                    }
                    
                    if (filteredNames.length === 0) {
                        nameGrid.innerHTML = '<div class="text-center py-4">No names found matching your criteria</div>';
                        return;
                    }
                    
                    filteredNames.forEach(name => {
                        const card = document.createElement('div');
                        card.className = 'name-card';
                        card.dataset.id = name.id;
                        
                        let translateField = name.english;
                        if (this.settings.language === 'urdu') translateField = name.urdu;
                        if (this.settings.language === 'pashto') translateField = name.pashto;
                        
                        card.innerHTML = `
                            <div class="name-card-header">
                                <h3>${name.transliteration}</h3>
                            </div>
                            <div class="name-card-body">
                                <div class="arabic">${name.name}</div>
                                <div class="meaning">${translateField}</div>
                            </div>
                            <div class="name-card-footer">
                                <span class="badge ${utils.getMasteryClass(name.mastery)}">${utils.getMasteryLabel(name.mastery)}</span>
                                <span>${name.favorite ? '★' : '☆'}</span>
                            </div>
                        `;
                        
                        card.addEventListener('click', () => this.showNameDetail(name.id));
                        nameGrid.appendChild(card);
                    });
                },
                
                showNameDetail: function(nameId) {
                    const name = this.names.find(n => n.id === nameId);
                    if (!name) return;
                    
                    this.currentName = name;
                    
                    document.getElementById('modalNameTitle').textContent = name.transliteration;
                    document.getElementById('modalNameArabic').textContent = name.name;
                    document.getElementById('modalNameEnglish').textContent = name.english;
                    document.getElementById('modalNameUrdu').textContent = name.urdu;
                    document.getElementById('modalNamePashto').textContent = name.pashto;
                    document.getElementById('modalNameDescription').textContent = name.description;
                    document.getElementById('modalMastery').textContent = utils.getMasteryLabel(name.mastery);
                    document.getElementById('modalMastery').className = `badge ${utils.getMasteryClass(name.mastery)}`;
                    document.getElementById('modalNextReview').textContent = utils.formatNextReview(name.nextReview);
                    
                    document.getElementById('favoriteIcon').style.fill = name.favorite ? 'gold' : 'currentColor';
                    
                    // Update stars
                    document.querySelectorAll('.star').forEach(star => {
                        const value = parseInt(star.dataset.value);
                        star.classList.toggle('filled', value <= name.mastery);
                    });
                    
                    document.getElementById('nameDetailModal').classList.add('active');
                },
                
                toggleFavorite: async function(nameId) {
                    const nameIndex = this.names.findIndex(n => n.id === nameId);
                    if (nameIndex === -1) return;
                    
                    this.names[nameIndex].favorite = !this.names[nameIndex].favorite;
                    
                    try {
                        await utils.saveToDb(NAMES_STORE, this.names[nameIndex]);
                        
                        // Update UI if modal is open
                        if (this.currentName && this.currentName.id === nameId) {
                            document.getElementById('favoriteIcon').style.fill = this.names[nameIndex].favorite ? 'gold' : 'currentColor';
                        }
                        
                        // Refresh names grid
                        this.renderNames();
                        
                        showNotification(
                            this.names[nameIndex].favorite 
                                ? `Added ${this.names[nameIndex].transliteration} to favorites` 
                                : `Removed ${this.names[nameIndex].transliteration} from favorites`
                        );
                    } catch (error) {
                        console.error('Error toggling favorite:', error);
                        showNotification('Error updating favorite status', 'error');
                    }
                },
                
                updateMastery: async function(nameId, mastery) {
                    const nameIndex = this.names.findIndex(n => n.id === nameId);
                    if (nameIndex === -1) return;
                    
                    this.names[nameIndex].mastery = mastery;
                    
                    // Calculate next review date based on mastery level
                    const now = new Date();
                    let interval = 1;
                    
                    switch (mastery) {
                        case 1: interval = 1; break;
                        case 2: interval = 3; break;
                        case 3: interval = 7; break;
                        case 4: interval = 14; break;
                        case 5: interval = 30; break;
                        default: interval = 1;
                    }
                    
                    const nextReview = new Date();
                    nextReview.setDate(now.getDate() + interval);
                    
                    this.names[nameIndex].nextReview = nextReview;
                    this.names[nameIndex].lastReviewed = now;
                    
                    try {
                        await utils.saveToDb(NAMES_STORE, this.names[nameIndex]);
                        
                        // Update UI
                        document.querySelectorAll('.star').forEach(star => {
                            const value = parseInt(star.dataset.value);
                            star.classList.toggle('filled', value <= mastery);
                        });
                        
                        document.getElementById('modalMastery').textContent = utils.getMasteryLabel(mastery);
                        document.getElementById('modalMastery').className = `badge ${utils.getMasteryClass(mastery)}`;
                        document.getElementById('modalNextReview').textContent = utils.formatNextReview(nextReview);
                        
                        // Refresh names grid
                        this.renderNames();
                        this.updateProgress();
                        
                        showNotification(`Mastery level updated for ${this.names[nameIndex].transliteration}`);
                    } catch (error) {
                        console.error('Error updating mastery:', error);
                        showNotification('Error updating mastery level', 'error');
                    }
                },
                
                startGame: function(mode) {
                    this.gameState = {
                        mode,
                        score: 0,
                        total: 0,
                        items: [],
                        started: true,
                        completed: false
                    };
                    
                    document.getElementById('gameArea').style.display = 'block';
                    
                    switch (mode) {
                        case 'match':
                            document.getElementById('gameTitle').textContent = 'Matching Game';
                            this.startMatchingGame();
                            break;
                        case 'memory':
                            document.getElementById('gameTitle').textContent = 'Memory Game';
                            this.startMemoryGame();
                            break;
                        case 'quiz':
                            document.getElementById('gameTitle').textContent = 'Quiz Challenge';
                            this.startQuizGame();
                            break;
                    }
                },
                
                startMatchingGame: function() {
                    // Select 5 random names
                    const gameNames = utils.shuffle([...this.names]).slice(0, 5);
                    this.gameState.items = gameNames;
                    this.gameState.total = gameNames.length;
                    
                    const gameContent = document.getElementById('gameContent');
                    gameContent.innerHTML = '';
                    
                    const instructionDiv = document.createElement('div');
                    instructionDiv.className = 'mb-3';
                    instructionDiv.textContent = 'Match each name with its correct meaning';
                    gameContent.appendChild(instructionDiv);
                    
                    // Create two columns - Arabic names and meanings (shuffled)
                    const nameCol = document.createElement('div');
                    nameCol.className = 'flex flex-col gap-2 mb-3';
                    
                    const meaningCol = document.createElement('div');
                    meaningCol.className = 'flex flex-col gap-2';
                    
                    const meanings = utils.shuffle([...gameNames]);
                    
                    gameNames.forEach((name, index) => {
                        const nameCard = document.createElement('div');
                        nameCard.className = 'quiz-card';
                        nameCard.dataset.index = index;
                        nameCard.dataset.id = name.id;
                        nameCard.innerHTML = `
                            <div class="arabic mb-1">${name.name}</div>
                            <div>${name.transliteration}</div>
                            <div class="mt-2">
                                <select class="btn btn-secondary w-full match-select">
                                    <option value="">-- Select meaning --</option>
                                    ${meanings.map((m, i) => `<option value="${m.id}">${m.english}</option>`).join('')}
                                </select>
                            </div>
                        `;
                        
                        nameCol.appendChild(nameCard);
                    });
                    
                    gameContent.appendChild(nameCol);
                    
                    // Add submit button
                    const submitDiv = document.createElement('div');
                    submitDiv.className = 'flex justify-center mt-2';
                    
                    const submitBtn = document.createElement('button');
                    submitBtn.className = 'btn';
                    submitBtn.textContent = 'Check Answers';
                    submitBtn.addEventListener('click', () => this.checkMatchingAnswers());
                    
                    submitDiv.appendChild(submitBtn);
                    gameContent.appendChild(submitDiv);
                    
                    // Track start time
                    this.gameState.startTime = new Date();
                },
                
                checkMatchingAnswers: function() {
                    const selects = document.querySelectorAll('.match-select');
                    let correct = 0;
                    let total = selects.length;
                    
                    selects.forEach(select => {
                        const nameCard = select.closest('.quiz-card');
                        const nameId = nameCard.dataset.id;
                        const selectedId = select.value;
                        
                        if (nameId === selectedId) {
                            select.classList.add('correct');
                            correct++;
                            
                            // Update SRS for this name
                            const nameIndex = this.names.findIndex(n => n.id === nameId);
                            if (nameIndex !== -1) {
                                const updatedName = utils.updateSrsInterval(this.names[nameIndex], true);
                                this.names[nameIndex] = updatedName;
                                utils.saveToDb(NAMES_STORE, updatedName);
                            }
                        } else {
                            select.classList.add('incorrect');
                            
                            // If incorrect, reduce SRS level
                            if (selectedId) {
                                const nameIndex = this.names.findIndex(n => n.id === nameId);
                                if (nameIndex !== -1) {
                                    const updatedName = utils.updateSrsInterval(this.names[nameIndex], false);
                                    this.names[nameIndex] = updatedName;
                                    utils.saveToDb(NAMES_STORE, updatedName);
                                }
                            }
                        }
                        
                        // Disable the select
                        select.disabled = true;
                    });
                    
                    this.gameState.score = correct;
                    this.gameState.completed = true;
                    
                    // Update progress bar
                    document.getElementById('gameProgress').style.width = `${(correct / total) * 100}%`;
                    
                    // Update game stats
                    this.updateGameStats();
                    
                    // Show results
                    const gameContent = document.getElementById('gameContent');
                    const resultsDiv = document.createElement('div');
                    resultsDiv.className = 'card mt-3 text-center';
                    resultsDiv.innerHTML = `
                        <h3>Results</h3>
                        <p class="mb-2">You got ${correct} out of ${total} correct!</p>
                        <button class="btn" id="playAgainBtn">Play Again</button>
                    `;
                    
                    gameContent.appendChild(resultsDiv);
                    
                    document.getElementById('playAgainBtn').addEventListener('click', () => {
                        this.startGame('match');
                    });
                },
                
                startMemoryGame: function() {
                    // Select 6 random names for 12 cards (6 pairs)
                    const gameNames = utils.shuffle([...this.names]).slice(0, 6);
                    this.gameState.items = gameNames;
                    
                    const gameContent = document.getElementById('gameContent');
                    gameContent.innerHTML = '';
                    
                    const instructionDiv = document.createElement('div');
                    instructionDiv.className = 'mb-3';
                    instructionDiv.textContent = 'Match each name with its meaning by flipping cards';
                    gameContent.appendChild(instructionDiv);
                    
                    // Create memory board
                    const board = document.createElement('div');
                    board.className = 'memory-board';
                    
                    // Create cards - one for Arabic name and one for meaning
                    const cards = [];
                    gameNames.forEach(name => {
                        cards.push({
                            id: name.id + '_name',
                            content: name.name,
                            type: 'name',
                            nameId: name.id,
                            matched: false
                        });
                        
                        cards.push({
                            id: name.id + '_meaning',
                            content: name.english,
                            type: 'meaning',
                            nameId: name.id,
                            matched: false
                        });
                    });
                    
                    // Shuffle cards
                    const shuffledCards = utils.shuffle(cards);
                    this.gameState.cards = shuffledCards;
                    
                    shuffledCards.forEach(card => {
                        const cardElement = document.createElement('div');
                        cardElement.className = 'memory-card';
                        cardElement.dataset.id = card.id;
                        
                        cardElement.innerHTML = `
                            <div class="memory-card-inner">
                                <div class="memory-card-front">
                                    <div>?</div>
                                </div>
                                <div class="memory-card-back">
                                    <div>${card.content}</div>
                                </div>
                            </div>
                        `;
                        
                        cardElement.addEventListener('click', () => this.flipCard(card.id));
                        board.appendChild(cardElement);
                    });
                    
                    gameContent.appendChild(board);
                    
                    // Track flipped cards and matches
                    this.gameState.flipped = [];
                    this.gameState.matches = 0;
                    this.gameState.total = gameNames.length;
                    
                    // Track start time
                    this.gameState.startTime = new Date();
                },
                
                flipCard: function(cardId) {
                    if (this.gameState.completed || this.gameState.checking) return;
                    
                    const cardIndex = this.gameState.cards.findIndex(c => c.id === cardId);
                    if (cardIndex === -1) return;
                    
                    const card = this.gameState.cards[cardIndex];
                    
                    // Don't allow flipping matched cards or already flipped cards
                    if (card.matched || this.gameState.flipped.includes(cardId)) return;
                    
                    // Don't allow more than 2 cards flipped at a time
                    if (this.gameState.flipped.length >= 2) return;
                    
                    // Flip the card
                    const cardElement = document.querySelector(`.memory-card[data-id="${cardId}"]`);
                    cardElement.classList.add('flipped');
                    
                    // Add to flipped cards
                    this.gameState.flipped.push(cardId);
                    
                    // Check for match if 2 cards are flipped
                    if (this.gameState.flipped.length === 2) {
                        this.gameState.checking = true;
                        
                        setTimeout(() => {
                            this.checkMemoryMatch();
                            this.gameState.checking = false;
                        }, 1000);
                    }
                },
                
                checkMemoryMatch: function() {
                    const cardId1 = this.gameState.flipped;
                    const cardId2 = this.gameState.flipped;
                    
                    const card1 = this.gameState.cards.find(c => c.id === cardId1);
                    const card2 = this.gameState.cards.find(c => c.id === cardId2);
                    
                    let isMatch = false;
                    
                    if (card1 && card2 && card1.nameId === card2.nameId && card1.type !== card2.type) {
                        // It's a match
                        card1.matched = true;
                        card2.matched = true;
                        
                        this.gameState.matches++;
                        
                        // Update UI
                        document.querySelector(`.memory-card[data-id="${cardId1}"]`).classList.add('matched');
                        document.querySelector(`.memory-card[data-id="${cardId2}"]`).classList.add('matched');
                        
                        isMatch = true;
                        
                        // Update progress bar
                        document.getElementById('gameProgress').style.width = `${(this.gameState.matches / this.gameState.total) * 100}%`;
                        
                        // Update SRS for this name
                        const nameIndex = this.names.findIndex(n => n.id === card1.nameId);
                        if (nameIndex !== -1) {
                            const updatedName = utils.updateSrsInterval(this.names[nameIndex], true);
                            this.names[nameIndex] = updatedName;
                            utils.saveToDb(NAMES_STORE, updatedName);
                        }
                        
                        // Check if game is completed
                        if (this.gameState.matches === this.gameState.total) {
                            this.gameState.completed = true;
                            this.gameState.score = this.gameState.matches;
                            
                            // Update game stats
                            this.updateGameStats();
                            
                            // Show results
                            const gameContent = document.getElementById('gameContent');
                            const resultsDiv = document.createElement('div');
                            resultsDiv.className = 'card mt-3 text-center';
                            resultsDiv.innerHTML = `
                                <h3>Congratulations!</h3>
                                <p class="mb-2">You matched all ${this.gameState.total} pairs!</p>
                                <button class="btn" id="playAgainBtn">Play Again</button>
                            `;
                            
                            gameContent.appendChild(resultsDiv);
                            
                            document.getElementById('playAgainBtn').addEventListener('click', () => {
                                this.startGame('memory');
                            });
                        }
                    } else {
                        // Not a match, flip back
                        document.querySelector(`.memory-card[data-id="${cardId1}"]`).classList.remove('flipped');
                        document.querySelector(`.memory-card[data-id="${cardId2}"]`).classList.remove('flipped');
                        
                        // If they tried to match but failed, reduce SRS
                        if (card1 && card2) {
                            const nameIndex = this.names.findIndex(n => n.id === card1.nameId);
                            if (nameIndex !== -1) {
                                const updatedName = utils.updateSrsInterval(this.names[nameIndex], false);
                                this.names[nameIndex] = updatedName;
                                utils.saveToDb(NAMES_STORE, updatedName);
                            }
                        }
                    }
                    
                    // Clear flipped cards
                    this.gameState.flipped = [];
                },
                
                startQuizGame: function() {
                    // Select 10 random names for quiz
                    const gameNames = utils.shuffle([...this.names]).slice(0, 10);
                    this.gameState.items = gameNames;
                    this.gameState.total = gameNames.length;
                    this.gameState.currentQuestion = 0;
                    
                    // Show first question
                    this.showQuizQuestion();
                    
                    // Track start time
                    this.gameState.startTime = new Date();
                },
                
                showQuizQuestion: function() {
                    if (this.gameState.currentQuestion >= this.gameState.total) {
                        // End of quiz
                        this.endQuiz();
                        return;
                    }
                    
                    const currentName = this.gameState.items[this.gameState.currentQuestion];
                    
                    // Get 3 random wrong answers
                    let wrongAnswers = this.names.filter(n => n.id !== currentName.id);
                    wrongAnswers = utils.shuffle(wrongAnswers).slice(0, 3);
                    
                    // Combine answers and shuffle
                    const answers = [currentName, ...wrongAnswers];
                    const shuffledAnswers = utils.shuffle(answers);
                    
                    const gameContent = document.getElementById('gameContent');
                    gameContent.innerHTML = '';
                    
                    // Update progress bar
                    document.getElementById('gameProgress').style.width = `${(this.gameState.currentQuestion / this.gameState.total) * 100}%`;
                    
                    // Create question
                    const questionDiv = document.createElement('div');
                    questionDiv.className = 'quiz-card';
                    
                    // Randomly choose between showing meaning and asking for name, or vice versa
                    const questionType = Math.random() > 0.5 ? 'meaning' : 'name';
                    
                    if (questionType === 'meaning') {
                        // Show Arabic name, ask for meaning
                        questionDiv.innerHTML = `
                            <h3 class="mb-3">What is the meaning of:</h3>
                            <div class="arabic mb-3">${currentName.name}</div>
                            <div class="mb-2">${currentName.transliteration}</div>
                        `;
                    } else {
                        // Show meaning, ask for name
                        questionDiv.innerHTML = `
                            <h3 class="mb-3">Which name means:</h3>
                            <div class="mb-3">${currentName.english}</div>
                        `;
                    }
                    
                    gameContent.appendChild(questionDiv);
                    
                    // Create options
                    const optionsDiv = document.createElement('div');
                    optionsDiv.className = 'quiz-options';
                    
                    shuffledAnswers.forEach(answer => {
                        const optionBtn = document.createElement('div');
                        optionBtn.className = 'quiz-option';
                        optionBtn.dataset.id = answer.id;
                        
                        if (questionType === 'meaning') {
                            optionBtn.textContent = answer.english;
                        } else {
                            optionBtn.innerHTML = `
                                <div class="arabic">${answer.name}</div>
                                <div>${answer.transliteration}</div>
                            `;
                        }
                        
                        optionBtn.addEventListener('click', () => this.checkQuizAnswer(answer.id, currentName.id));
                        optionsDiv.appendChild(optionBtn);
                    });
                    
                    gameContent.appendChild(optionsDiv);
                },
                
                checkQuizAnswer: function(answerId, correctId) {
                    // Prevent multiple answers
                    if (this.gameState.answerChecked) return;
                    this.gameState.answerChecked = true;
                    
                    const isCorrect = answerId === correctId;
                    
                    // Mark options
                    document.querySelectorAll('.quiz-option').forEach(option => {
                        const optionId = option.dataset.id;
                        
                        if (optionId === correctId) {
                            option.classList.add('correct');
                        } else if (optionId === answerId) {
                            option.classList.add('incorrect');
                        }
                        
                        // Disable clicking
                        option.style.pointerEvents = 'none';
                    });
                    
                    // Update score
                    if (isCorrect) {
                        this.gameState.score++;
                        
                        // Update SRS for this name
                        const nameIndex = this.names.findIndex(n => n.id === correctId);
                        if (nameIndex !== -1) {
                            const updatedName = utils.updateSrsInterval(this.names[nameIndex], true);
                            this.names[nameIndex] = updatedName;
                            utils.saveToDb(NAMES_STORE, updatedName);
                        }
                    } else {
                        // If incorrect, reduce SRS level
                        const nameIndex = this.names.findIndex(n => n.id === correctId);
                        if (nameIndex !== -1) {
                            const updatedName = utils.updateSrsInterval(this.names[nameIndex], false);
                            this.names[nameIndex] = updatedName;
                            utils.saveToDb(NAMES_STORE, updatedName);
                        }
                    }
                    
                    // Show next button
                    const gameContent = document.getElementById('gameContent');
                    const nextBtn = document.createElement('div');
                    nextBtn.className = 'flex justify-center mt-3';
                    nextBtn.innerHTML = `<button class="btn">Next Question</button>`;
                    
                    nextBtn.querySelector('button').addEventListener('click', () => {
                        this.gameState.currentQuestion++;
                        this.gameState.answerChecked = false;
                        this.showQuizQuestion();
                    });
                    
                    gameContent.appendChild(nextBtn);
                },
                
                endQuiz: function() {
                    this.gameState.completed = true;
                    
                    // Update game stats
                    this.updateGameStats();
                    
                    // Show results
                    const gameContent = document.getElementById('gameContent');
                    gameContent.innerHTML = '';
                    
                    const resultsDiv = document.createElement('div');
                    resultsDiv.className = 'card text-center';
                    
                    // Calculate percentage
                    const percentage = Math.round((this.gameState.score / this.gameState.total) * 100);
                    
                    resultsDiv.innerHTML = `
                        <h3 class="mb-2">Quiz Completed!</h3>
                        <p class="mb-3">Your score: ${this.gameState.score} out of ${this.gameState.total} (${percentage}%)</p>
                        <div class="mb-3">
                            ${percentage >= 80 ? 
                                '<p>Excellent! You have a great understanding of the Beautiful Names.</p>' :
                                percentage >= 50 ?
                                    '<p>Good job! Keep learning to improve your knowledge.</p>' :
                                    '<p>Keep practicing! You\'ll get better with time.</p>'
                            }
                        </div>
                        <button class="btn" id="playAgainBtn">Play Again</button>
                    `;
                    
                    gameContent.appendChild(resultsDiv);
                    
                    document.getElementById('playAgainBtn').addEventListener('click', () => {
                        this.startGame('quiz');
                    });
                    
                    // Update progress bar to 100%
                    document.getElementById('gameProgress').style.width = '100%';
                },
                
                endGame: function() {
                    document.getElementById('gameArea').style.display = 'none';
                    this.gameState = {
                        mode: null,
                        score: 0,
                        total: 0,
                        items: [],
                        started: false,
                        completed: false
                    };
                },
                
                updateGameStats: function() {
                    if (!this.gameState.startTime || !this.gameState.completed) return;
                    
                    // Calculate time spent
                    const endTime = new Date();
                    const timeSpent = (endTime - this.gameState.startTime) / 1000 / 60; // In minutes
                    
                    // Update progress
                    this.progress.gamesPlayed += 1;
                    this.progress.timeSpent += timeSpent;
                    
                    // Update daily streak
                    this.checkDailyStreak();
                    
                    // Save progress
                    utils.saveToDb(PROGRESS_STORE, this.progress);
                    
                    // Update UI
                    this.updateProgress();
                },
                
                checkDailyStreak: function() {
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    
                    const lastDate = this.progress.streak.lastDate ? new Date(this.progress.streak.lastDate) : null;
                    
                    if (lastDate) {
                        lastDate.setHours(0, 0, 0, 0);
                        
                        const diff = (today - lastDate) / (1000 * 60 * 60 * 24);
                        
                        if (diff === 1) {
                            // Consecutive day
                            this.progress.streak.current += 1;
                            if (this.progress.streak.current > this.progress.streak.longest) {
                                this.progress.streak.longest = this.progress.streak.current;
                            }
                        } else if (diff > 1) {
                            // Streak broken
                            this.progress.streak.current = 1;
                        }
                        // If diff === 0, it's the same day, don't update streak
                    } else {
                        // First time
                        this.progress.streak.current = 1;
                        this.progress.streak.longest = 1;
                    }
                    
                    this.progress.streak.lastDate = today;
                    utils.saveToDb(PROGRESS_STORE, this.progress);
                },
                
                updateProgress: function() {
                    // Update mastery stats
                    const mastered = this.names.filter(n => n.mastery >= 5).length;
                    document.getElementById('namesMastered').textContent = mastered;
                    document.getElementById('masteryProgress').style.width = `${(mastered / this.names.length) * 100}%`;
                    
                    // Update game stats
                    document.getElementById('gamesPlayed').textContent = this.progress.gamesPlayed;
                    document.getElementById('timeSpent').textContent = `${Math.round(this.progress.timeSpent)} min`;
                    document.getElementById('currentStreak').textContent = `${this.progress.streak.current} days`;
                    
                    // Update review schedule
                    this.updateReviewSchedule();
                },
                
                updateReviewSchedule: function() {
                    const reviewSchedule = document.getElementById('reviewSchedule');
                    reviewSchedule.innerHTML = '';
                    
                    const now = new Date();
                    now.setHours(0, 0, 0, 0);
                    
                    // Get names due for review
                    const dueNames = this.names.filter(name => {
                        if (!name.nextReview) return false;
                        
                        const reviewDate = new Date(name.nextReview);
                        reviewDate.setHours(0, 0, 0, 0);
                        
                        return reviewDate <= now;
                    });
                    
                    if (dueNames.length === 0) {
                        reviewSchedule.innerHTML = '<div class="text-center py-4">No names scheduled for review today</div>';
                        return;
                    }
                    
                    // Sort by mastery level (lowest first)
                    dueNames.sort((a, b) => a.mastery - b.mastery);
                    
                    dueNames.forEach(name => {
                        const nameItem = document.createElement('div');
                        nameItem.className = 'flex justify-between items-center';
                        nameItem.innerHTML = `
                            <div>${name.transliteration}</div>
                            <div class="flex gap-2">
                                <span class="badge ${utils.getMasteryClass(name.mastery)}">${utils.getMasteryLabel(name.mastery)}</span>
                                <button class="btn btn-secondary btn-round review-btn" data-id="${name.id}">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                        <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-5.904-2.803a.5.5 0 1 0-.707.707L10.293 8 9.389 9.103a.5.5 0 1 0 .707.707l1.414-1.414a.5.5 0 0 0 0-.707l-1.414-1.414zM5.717 6.5A.5.5 0 0 0 5.5 6H4a.5.5 0 0 0 0 1h1v1H4a.5.5 0 0 0 0 1h1v1H4a.5.5 0 0 0 0 1h1.5a.5.5 0 0 0 .5-.5V6.5z"/>
                                    </svg>
                                </button>
                            </div>
                        `;
                        
                        reviewSchedule.appendChild(nameItem);
                    });
                    
                    // Add event listeners to review buttons
                    document.querySelectorAll('.review-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const nameId = btn.dataset.id;
                            const name = this.names.find(n => n.id === nameId);
                            
                            if (name) {
                                this.showNameDetail(nameId);
                            }
                        });
                    });
                },
                
                exportData: function() {
                    const data = {
                        names: this.names,
                        settings: this.settings,
                        progress: this.progress
                    };
                    
                    const dataStr = JSON.stringify(data);
                    const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                    
                    const exportFileDefaultName = 'beautiful_names_data.json';
                    
                    const linkElement = document.createElement('a');
                    linkElement.setAttribute('href', dataUri);
                    linkElement.setAttribute('download', exportFileDefaultName);
                    linkElement.click();
                    
                    showNotification('Data exported successfully');
                },
                
                importData: function() {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'application/json';
                    
                    input.onchange = e => {
                        const file = e.target.files;
                        
                        if (!file) return;
                        
                        const reader = new FileReader();
                        reader.onload = async (event) => {
                            try {
                                const data = JSON.parse(event.target.result);
                                
                                if (data.names && Array.isArray(data.names)) {
                                    await utils.clearStore(NAMES_STORE);
                                    for (const name of data.names) {
                                        await utils.saveToDb(NAMES_STORE, name);
                                    }
                                    this.names = data.names;
                                }
                                
                                if (data.settings) {
                                    await utils.saveToDb(SETTINGS_STORE, data.settings);
                                    this.settings = data.settings;
                                    this.updateTheme();
                                }
                                
                                if (data.progress) {
                                    await utils.saveToDb(PROGRESS_STORE, data.progress);
                                    this.progress = data.progress;
                                }
                                
                                this.renderNames();
                                this.updateProgress();
                                
                                showNotification('Data imported successfully');
                            } catch (error) {
                                console.error('Error importing data:', error);
                                showNotification('Error importing data: Invalid file format', 'error');
                            }
                        };
                        
                        reader.readAsText(file);
                    };
                    
                    input.click();
                },
                
                resetData: function() {
                    if (confirm('Are you sure you want to reset all data? This cannot be undone.')) {
                        Promise.all([
                            utils.clearStore(NAMES_STORE),
                            utils.clearStore(SETTINGS_STORE),
                            utils.clearStore(PROGRESS_STORE)
                        ]).then(() => {
                            // Reinitialize app
                            this.settings = { ...DEFAULT_SETTINGS };
                            this.progress = { ...DEFAULT_PROGRESS };
                            
                            // Reset names
                            this.names = [];
                            for (const name of NAMES_DATA) {
                                utils.saveToDb(NAMES_STORE, name);
                            }
                            this.names = NAMES_DATA;
                            
                            // Save default settings and progress
                            utils.saveToDb(SETTINGS_STORE, this.settings);
                            utils.saveToDb(PROGRESS_STORE, this.progress);
                            
                            this.updateTheme();
                            this.renderNames();
                            this.updateProgress();
                            
                            showNotification('All data has been reset');
                        }).catch(error => {
                            console.error('Error resetting data:', error);
                            showNotification('Error resetting data', 'error');
                        });
                    }
                },
                
                requestNotificationPermission: function() {
                    if (!('Notification' in window)) {
                        showNotification('Notifications are not supported in this browser', 'error');
                        return;
                    }
                    
                    if (Notification.permission !== 'granted' && Notification.permission !== 'denied') {
                        Notification.requestPermission().then(permission => {
                            if (permission === 'granted') {
                                showNotification('Notifications enabled');
                            }
                        });
                    }
                }
            };
            
            // Notification utility
            function showNotification(message, type = 'success') {
                const notification = document.getElementById('notification');
                const notificationMessage = document.getElementById('notificationMessage');
                
                notificationMessage.textContent = message;
                notification.className = 'notification';
                notification.classList.add(type);
                
                // Show notification
                setTimeout(() => {
notification.classList.add('show');

                    // Hide after 3 seconds
                    setTimeout(() => {
                        notification.classList.remove('show');
                    }, 3000);
                }, 100);
            }
            
            function initApp() {
                app.init();
            }

    </script>
    </body>
</html>
